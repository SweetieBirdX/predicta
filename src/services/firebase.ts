import { 
  collection, 
  doc, 
  addDoc, 
  getDoc, 
  getDocs, 
  updateDoc, 
  query, 
  where, 
  orderBy, 
  limit,
  Timestamp,
  increment,
  deleteDoc,
  writeBatch
} from 'firebase/firestore';
import { db } from '../lib/firebase';
import { User, Prediction, Vote, LeaderboardEntry, Badge, UserBadge, BadgeProgress, BADGE_DEFINITIONS } from '../types';

// User operations
export const createUser = async (userData: Omit<User, 'id' | 'createdAt'>): Promise<string> => {
  try {
    const userDoc = {
      privyId: userData.privyId || '',
      walletAddress: userData.walletAddress || '',
      email: userData.email || '',
      createdAt: Timestamp.now(),
      xp: 0,
      correctPredictions: 0,
      totalPredictions: 0,
      badges: []
    };
    
    console.log('üî• Creating user:', userDoc);
    
    const userRef = await addDoc(collection(db, 'users'), userDoc);
    
    console.log('‚úÖ User created, ID:', userRef.id);
    
    // üèÜ WELCOME BADGE: Give welcome badge to new user
    console.log(`üéâ Awarding welcome badge to new user...`);
    const welcomeBadges = await checkAndAwardBadges(userRef.id, 0);
    
    if (welcomeBadges.length > 0) {
      console.log(`üéâ ${welcomeBadges.length} welcome badge(s) awarded!`);
      for (const badge of welcomeBadges) {
        console.log(`üèÜ New badge: ${badge.badgeId}`);
      }
    }
    
    return userRef.id;
  } catch (error) {
    console.error('User creation error:', error);
    throw error;
  }
};

export const getUser = async (userId: string): Promise<User | null> => {
  try {
    const userDoc = await getDoc(doc(db, 'users', userId));
    if (userDoc.exists()) {
      const data = userDoc.data();
      return {
        id: userDoc.id,
        ...data,
        createdAt: data.createdAt.toDate()
      } as User;
    }
    return null;
  } catch (error) {
    console.error('User retrieval error:', error);
    throw error;
  }
};

export const getUserByEmail = async (email: string): Promise<User | null> => {
  try {
    console.log(`üîç Searching for user by email: ${email}`);
    
    const q = query(
      collection(db, 'users'),
      where('email', '==', email),
      limit(1)
    );
    
    const querySnapshot = await getDocs(q);
    
    if (!querySnapshot.empty) {
      const userDoc = querySnapshot.docs[0];
      const data = userDoc.data();
      const user = {
        id: userDoc.id,
        ...data,
        createdAt: data.createdAt.toDate()
      } as User;
      
      console.log(`‚úÖ Existing user found: ${user.id}`);
      return user;
    }
    
    console.log(`‚ùå No user found with this email: ${email}`);
    return null;
  } catch (error) {
    console.error('User search by email error:', error);
    throw error;
  }
};

// User search function by Privy ID
export const getUserByPrivyId = async (privyId: string): Promise<User | null> => {
  try {
    console.log(`üîç Searching for user by Privy ID: ${privyId}`);
    
    const q = query(
      collection(db, 'users'),
      where('privyId', '==', privyId),
      limit(1)
    );
    
    const querySnapshot = await getDocs(q);
    
    if (!querySnapshot.empty) {
      const userDoc = querySnapshot.docs[0];
      const data = userDoc.data();
      const user = {
        id: userDoc.id,
        ...data,
        createdAt: data.createdAt.toDate()
      } as User;
      
      console.log(`‚úÖ User found by Privy ID: ${user.id}`);
      return user;
    }
    
    console.log(`‚ùå No user found with this Privy ID: ${privyId}`);
    return null;
  } catch (error) {
    console.error('User search by Privy ID error:', error);
    throw error;
  }
};

// Function to update user's Privy ID
export const updateUserPrivyId = async (userId: string, privyId: string): Promise<void> => {
  try {
    console.log(`üîÑ Updating Privy ID: User ${userId} -> Privy ${privyId}`);
    
    await updateDoc(doc(db, 'users', userId), {
      privyId: privyId
    });
    
    console.log(`‚úÖ Privy ID successfully updated`);
  } catch (error) {
    console.error('Privy ID update error:', error);
    throw error;
  }
};

export const updateUser = async (userId: string, updates: Partial<User>): Promise<void> => {
  try {
    await updateDoc(doc(db, 'users', userId), updates);
  } catch (error) {
    console.error('User update error:', error);
    throw error;
  }
};

// Prediction operations
export const createPrediction = async (predictionData: Omit<Prediction, 'id' | 'createdAt' | 'totalVotes' | 'yesVotes' | 'noVotes'>): Promise<string> => {
  try {
    const predictionRef = await addDoc(collection(db, 'predictions'), {
      ...predictionData,
      createdAt: Timestamp.now(),
      totalVotes: 0,
      yesVotes: 0,
      noVotes: 0,
      endDate: Timestamp.fromDate(predictionData.endDate)
    });
    console.log(`üéØ Prediction created: ${predictionRef.id}, Correct answer: ${predictionData.correctAnswer}`);
    return predictionRef.id;
  } catch (error) {
    console.error('Prediction creation error:', error);
    throw error;
  }
};

export const getActivePredictions = async (): Promise<Prediction[]> => {
  try {
    const q = query(
      collection(db, 'predictions'),
      where('status', '==', 'active')
    );
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        createdAt: data.createdAt.toDate(),
        endDate: data.endDate.toDate()
      } as unknown as Prediction;
    });
  } catch (error) {
    console.error('Aktif tahminleri alma hatasƒ±:', error);
    throw error;
  }
};

export const getPrediction = async (predictionId: string): Promise<Prediction | null> => {
  try {
    const predictionDoc = await getDoc(doc(db, 'predictions', predictionId));
    if (predictionDoc.exists()) {
      const data = predictionDoc.data();
      return {
        id: predictionDoc.id,
        ...data,
        createdAt: data.createdAt.toDate(),
        endDate: data.endDate.toDate()
      } as unknown as Prediction;
    }
    return null;
  } catch (error) {
    console.error('Tahmin alma hatasƒ±:', error);
    throw error;
  }
};

export const resolvePrediction = async (predictionId: string, result: 'yes' | 'no'): Promise<void> => {
  try {
    await updateDoc(doc(db, 'predictions', predictionId), {
      status: 'resolved',
      result: result
    });
    
    // Doƒüru tahmin yapanlarƒ± bul ve XP ver
    await distributeXP(predictionId, result);
  } catch (error) {
    console.error('Tahmin sonu√ßlandƒ±rma hatasƒ±:', error);
    throw error;
  }
};

// Oy i≈ülemleri
export const createVote = async (voteData: Omit<Vote, 'id' | 'createdAt'>): Promise<{voteId: string, newBadges: UserBadge[]}> => {
  try {
    console.log(`üó≥Ô∏è Oy veriliyor: Kullanƒ±cƒ± ${voteData.userId}, Tahmin ${voteData.predictionId}, Se√ßim: ${voteData.choice}`);
    
    // √ñnce kullanƒ±cƒ±nƒ±n bu tahmin i√ßin oy verip vermediƒüini kontrol et
    const existingVoteQuery = query(
      collection(db, 'votes'),
      where('userId', '==', voteData.userId),
      where('predictionId', '==', voteData.predictionId)
    );
    const existingVotes = await getDocs(existingVoteQuery);
    
    if (!existingVotes.empty) {
      throw new Error('Bu tahmin i√ßin zaten oy kullandƒ±nƒ±z');
    }

    // Oy olu≈ütur
    const voteRef = await addDoc(collection(db, 'votes'), {
      ...voteData,
      createdAt: Timestamp.now()
    });

    console.log(`‚úÖ Oy ba≈üarƒ±yla kaydedildi: ${voteRef.id}`);

    // üéØ OY VERME √ñD√úL√ú: Her oy i√ßin 5 XP ver!
    console.log(`üíé Oy verme √∂d√ºl√º veriliyor: Kullanƒ±cƒ± ${voteData.userId} ‚Üí +5 XP`);
    
    try {
      const voterRef = doc(db, 'users', voteData.userId);
      const voterDoc = await getDoc(voterRef);
      
      if (voterDoc.exists()) {
        const voterData = voterDoc.data();
        const currentXP = voterData.xp || 0;
        const currentTotal = voterData.totalPredictions || 0;
        
        console.log(`üìä Kullanƒ±cƒ± ${voteData.userId} - Mevcut XP: ${currentXP}`);
        
        const newXP = currentXP + 5;
        await updateDoc(voterRef, {
          xp: newXP, // Her oy i√ßin 5 XP
          totalPredictions: currentTotal + 1 // Toplam tahmin sayƒ±sƒ±nƒ± artƒ±r
        });
        
        console.log(`‚úÖ Oy verme √∂d√ºl√º verildi! Kullanƒ±cƒ± ${voteData.userId} - YENƒ∞ XP: ${newXP}`);
        
        // üèÜ ROZET KONTROL√ú: XP artƒ±≈üƒ± sonrasƒ± rozet kontrol√º yap
        console.log(`üèÜ Rozet kontrol√º yapƒ±lƒ±yor...`);
        const newBadges = await checkAndAwardBadges(voteData.userId, newXP);
        
        if (newBadges.length > 0) {
          console.log(`üéâ ${newBadges.length} yeni rozet kazanƒ±ldƒ±!`);
          for (const badge of newBadges) {
            console.log(`üèÜ Yeni rozet: ${badge.badgeId}`);
          }
        }
        
        // Tahmin istatistiklerini g√ºncelle
        const predictionRef = doc(db, 'predictions', voteData.predictionId);
        const predictionDoc = await getDoc(predictionRef);
        
        if (predictionDoc.exists()) {
          const predictionData = predictionDoc.data();
          if (predictionData) {
            const currentTotal = predictionData!.totalVotes || 0;
            const currentChoice = predictionData![`${voteData.choice}Votes`] || 0;
            
            await updateDoc(predictionRef, {
              totalVotes: currentTotal + 1,
              [`${voteData.choice}Votes`]: currentChoice + 1
            });
            
            console.log(`üìä Tahmin istatistikleri g√ºncellendi - Toplam: ${currentTotal + 1}, ${voteData.choice}: ${currentChoice + 1}`);
          }
        }
        
        return {
          voteId: voteRef.id,
          newBadges: newBadges
        };
      } else {
        console.error(`‚ùå Oy veren kullanƒ±cƒ± ${voteData.userId} d√∂k√ºmanƒ± bulunamadƒ±!`);
        return {
          voteId: voteRef.id,
          newBadges: []
        };
      }
    } catch (xpError) {
      console.error(`‚ùå Oy verme XP hatasƒ±:`, xpError);
      return {
        voteId: voteRef.id,
        newBadges: []
      };
    }
  } catch (error) {
    console.error('Oy olu≈üturma hatasƒ±:', error);
    throw error;
  }
};

export const getUserVote = async (userId: string, predictionId: string): Promise<Vote | null> => {
  try {
    const q = query(
      collection(db, 'votes'),
      where('userId', '==', userId),
      where('predictionId', '==', predictionId)
    );
    const querySnapshot = await getDocs(q);
    
    if (!querySnapshot.empty) {
      const doc = querySnapshot.docs[0];
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        createdAt: data.createdAt.toDate()
      } as unknown as Vote;
    }
    return null;
  } catch (error) {
    console.error('Kullanƒ±cƒ± oyu alma hatasƒ±:', error);
    throw error;
  }
};

// XP daƒüƒ±tƒ±m fonksiyonu
const distributeXP = async (predictionId: string, correctResult: 'yes' | 'no'): Promise<void> => {
  try {
    console.log(`üéØ XP daƒüƒ±tƒ±mƒ± ba≈ülƒ±yor - Tahmin: ${predictionId}, Doƒüru sonu√ß: ${correctResult}`);
    
    // Doƒüru oy veren kullanƒ±cƒ±larƒ± bul
    const correctVotesQuery = query(
      collection(db, 'votes'),
      where('predictionId', '==', predictionId),
      where('choice', '==', correctResult)
    );
    const correctVotes = await getDocs(correctVotesQuery);
    
    console.log(`‚úÖ Doƒüru oy veren kullanƒ±cƒ± sayƒ±sƒ±: ${correctVotes.docs.length}`);

    // T√ºm oylarƒ± bul (totalPredictions i√ßin)
    const allVotesQuery = query(
      collection(db, 'votes'),
      where('predictionId', '==', predictionId)
    );
    const allVotes = await getDocs(allVotesQuery);
    
    console.log(`üìä Toplam oy sayƒ±sƒ±: ${allVotes.docs.length}`);

    // üèÜ DOƒûRU TAHMƒ∞N BONUS: Doƒüru oy veren kullanƒ±cƒ±lara ek 10 XP ver!
    for (const voteDoc of correctVotes.docs) {
      const vote = voteDoc.data();
      const userRef = doc(db, 'users', vote.userId);
      
      console.log(`üèÜ DOƒûRU TAHMƒ∞N BONUS: Kullanƒ±cƒ± ${vote.userId} i√ßin ek 10 XP veriliyor...`);
      
      try {
        // √ñnce kullanƒ±cƒ±nƒ±n mevcut verilerini al
        const userDoc = await getDoc(userRef);
        
        if (userDoc.exists()) {
          const userData = userDoc.data();
          const currentXP = userData.xp || 0;
          const currentCorrect = userData.correctPredictions || 0;
          
          console.log(`üìä Kullanƒ±cƒ± ${vote.userId} - Mevcut XP: ${currentXP}, Doƒüru tahmin: ${currentCorrect}`);
          
          // Ek 10 XP ver ve doƒüru tahmin sayƒ±sƒ±nƒ± artƒ±r
          const newXP = currentXP + 10;
          await updateDoc(userRef, {
            xp: newXP, // Ek 10 XP (zaten oy verirken 5 XP almƒ±≈ütƒ±)
            correctPredictions: currentCorrect + 1
          });
          
          console.log(`‚úÖ DOƒûRU TAHMƒ∞N BONUS! Kullanƒ±cƒ± ${vote.userId} - YENƒ∞ XP: ${newXP} (+10 bonus), Doƒüru tahmin: ${currentCorrect + 1}`);
          console.log(`üéâ Toplam kazanƒ±m: 5 XP (oy) + 10 XP (doƒüru bonus) = 15 XP!`);
          
          // üèÜ ROZET KONTROL√ú: Doƒüru tahmin bonusu sonrasƒ± rozet kontrol√º yap
          console.log(`üèÜ Doƒüru tahmin bonus sonrasƒ± rozet kontrol√º yapƒ±lƒ±yor...`);
          const newBadges = await checkAndAwardBadges(vote.userId, newXP);
          
          if (newBadges.length > 0) {
            console.log(`üéâ ${newBadges.length} yeni rozet kazanƒ±ldƒ±!`);
            for (const badge of newBadges) {
              console.log(`üèÜ Yeni rozet: ${badge.badgeId}`);
            }
          }
        } else {
          console.error(`‚ùå Kullanƒ±cƒ± ${vote.userId} d√∂k√ºmanƒ± bulunamadƒ±!`);
        }
      } catch (userError) {
        console.error(`‚ùå Kullanƒ±cƒ± ${vote.userId} XP g√ºncelleme hatasƒ±:`, userError);
      }
    }

    // ‚ÑπÔ∏è NOT: totalPredictions artƒ±k oy verirken g√ºncelleniyor, burada tekrar artƒ±rmaya gerek yok
    console.log(`‚ÑπÔ∏è totalPredictions zaten oy verirken g√ºncellendi, tekrar artƒ±rƒ±lmadƒ±`)
    
    console.log(`üéâ XP daƒüƒ±tƒ±mƒ± tamamlandƒ±!`);
  } catch (error) {
    console.error('XP daƒüƒ±tƒ±m hatasƒ±:', error);
    throw error;
  }
};

// Leaderboard
// Otomatik sonu√ßlandƒ±rma - S√ºresi dolmu≈ü tahminleri kontrol et
export const checkAndResolveExpiredPredictions = async (): Promise<void> => {
  try {
    console.log('‚è∞ S√ºresi dolmu≈ü tahminler kontrol ediliyor...');
    
    const now = new Date();
    const q = query(
      collection(db, 'predictions'),
      where('status', '==', 'active')
    );
    
    const querySnapshot = await getDocs(q);
    const predictions = querySnapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        createdAt: data.createdAt.toDate(),
        endDate: data.endDate.toDate()
      } as unknown as Prediction;
    });
    
    let resolvedCount = 0;
    
    for (const prediction of predictions) {
      if (prediction.endDate <= now) {
        console.log(`‚è∞ S√ºresi dolmu≈ü tahmin bulundu: ${prediction.id} - Doƒüru cevap: ${prediction.correctAnswer}`);
        
        // Sadece correctAnswer belirlenmi≈ü tahminleri otomatik sonu√ßlandƒ±r
        if (prediction.correctAnswer) {
          // Otomatik sonu√ßlandƒ±r
          await updateDoc(doc(db, 'predictions', prediction.id), {
            status: 'resolved',
            result: prediction.correctAnswer
          });
          
          // XP daƒüƒ±t
          await distributeXP(prediction.id, prediction.correctAnswer);
          
          resolvedCount++;
          console.log(`‚úÖ Tahmin otomatik sonu√ßlandƒ±rƒ±ldƒ±: ${prediction.id} - Sonu√ß: ${prediction.correctAnswer}`);
        } else {
          console.log(`‚è∏Ô∏è Tahmin s√ºresi doldu ama admin tarafƒ±ndan sonu√ßlandƒ±rƒ±lmayƒ± bekliyor: ${prediction.id}`);
        }
      }
    }
    
    if (resolvedCount > 0) {
      console.log(`üéâ Toplam ${resolvedCount} tahmin otomatik sonu√ßlandƒ±rƒ±ldƒ±!`);
    } else {
      console.log('‚úÖ S√ºresi dolmu≈ü tahmin bulunamadƒ±.');
    }
  } catch (error) {
    console.error('Otomatik sonu√ßlandƒ±rma hatasƒ±:', error);
  }
};

// Kullanƒ±cƒ±nƒ±n sonu√ßlanmƒ±≈ü tahminlerini getir
export const getUserResolvedPredictions = async (userId: string): Promise<any[]> => {
  try {
    console.log(`üìú Kullanƒ±cƒ±nƒ±n ge√ßmi≈ü tahminleri getiriliyor: ${userId}`);
    
    // 1. Kullanƒ±cƒ±nƒ±n oylarƒ±nƒ± al
    const votesQuery = query(
      collection(db, 'votes'),
      where('userId', '==', userId)
    );
    const votesSnapshot = await getDocs(votesQuery);
    
    // 2. Sonu√ßlanmƒ±≈ü tahminleri al
    const resolvedQuery = query(
      collection(db, 'predictions'),
      where('status', '==', 'resolved')
    );
    const resolvedSnapshot = await getDocs(resolvedQuery);
    
    // 3. Kullanƒ±cƒ±nƒ±n oyladƒ±ƒüƒ± ve sonu√ßlanmƒ±≈ü tahminleri e≈üle≈ütir
    const userVotes = votesSnapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        userId: data.userId,
        predictionId: data.predictionId,
        choice: data.choice,
        createdAt: data.createdAt.toDate()
      } as unknown as Vote;
    });
    
    const resolvedPredictions = resolvedSnapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        createdAt: data.createdAt.toDate(),
        endDate: data.endDate.toDate()
      } as unknown as Prediction;
    });
    
    // 4. Kullanƒ±cƒ±nƒ±n katƒ±ldƒ±ƒüƒ± sonu√ßlanmƒ±≈ü tahminleri birle≈ütir
    const userResolvedPredictions = [];
    
    for (const vote of userVotes) {
      const prediction = resolvedPredictions.find(p => p.id === vote.predictionId);
      if (prediction) {
        const isCorrect = vote.choice === prediction.result;
        const xpEarned = isCorrect ? 15 : 5; // Doƒüru: 15 XP, Yanlƒ±≈ü: 5 XP
        
        userResolvedPredictions.push({
          ...prediction,
          userVote: vote.choice,
          isCorrect,
          xpEarned,
          voteDate: (vote as any).createdAt
        });
      }
    }
    
    // 5. Tarihine g√∂re sƒ±rala (en yeni √∂nce)
    userResolvedPredictions.sort((a, b) => b.voteDate.getTime() - a.voteDate.getTime());
    
    console.log(`‚úÖ ${userResolvedPredictions.length} ge√ßmi≈ü tahmin bulundu`);
    return userResolvedPredictions;
  } catch (error) {
    console.error('Ge√ßmi≈ü tahminler alma hatasƒ±:', error);
    throw error;
  }
};

export const getLeaderboard = async (limitCount: number = 10): Promise<LeaderboardEntry[]> => {
  try {
    const q = query(
      collection(db, 'users'),
      limit(limitCount)
    );
    const querySnapshot = await getDocs(q);
    
    const users = querySnapshot.docs.map(doc => {
      const data = doc.data();
      const successRate = data.totalPredictions > 0 
        ? (data.correctPredictions / data.totalPredictions) * 100 
        : 0;
      
      return {
        userId: doc.id,
        xp: data.xp,
        correctPredictions: data.correctPredictions,
        totalPredictions: data.totalPredictions,
        successRate: Math.round(successRate)
      } as LeaderboardEntry;
    });
    
    // Frontend'de sƒ±rala (XP'ye g√∂re azalan)
    return users.sort((a, b) => b.xp - a.xp);
  } catch (error) {
    console.error('Leaderboard alma hatasƒ±:', error);
    throw error;
  }
};

// Kullanƒ±cƒ± profili i√ßin yeni fonksiyonlar
export const getUserActivities = async (userId: string): Promise<any[]> => {
  try {
    console.log(`üìä Kullanƒ±cƒ±nƒ±n aktiviteleri getiriliyor: ${userId}`);
    
    // 1. Kullanƒ±cƒ±nƒ±n oylarƒ±nƒ± al
    let votesSnapshot;
    try {
      const votesQuery = query(
        collection(db, 'votes'),
        where('userId', '==', userId),
        orderBy('createdAt', 'desc'),
        limit(10)
      );
      votesSnapshot = await getDocs(votesQuery);
    } catch (error) {
      console.log('Index eksik, sƒ±ralama olmadan alƒ±nƒ±yor...');
      const votesQuery = query(
        collection(db, 'votes'),
        where('userId', '==', userId),
        limit(10)
      );
      votesSnapshot = await getDocs(votesQuery);
    }
    
    // 2. Kullanƒ±cƒ±nƒ±n olu≈üturduƒüu tahminleri al
    let predictionsSnapshot;
    try {
      const predictionsQuery = query(
        collection(db, 'predictions'),
        where('creatorId', '==', userId),
        orderBy('createdAt', 'desc'),
        limit(10)
      );
      predictionsSnapshot = await getDocs(predictionsQuery);
    } catch (error) {
      console.log('Index eksik, sƒ±ralama olmadan alƒ±nƒ±yor...');
      const predictionsQuery = query(
        collection(db, 'predictions'),
        where('creatorId', '==', userId),
        limit(10)
      );
      predictionsSnapshot = await getDocs(predictionsQuery);
    }
    
    // 3. Aktiviteleri birle≈ütir
    const activities = [];
    
    // Oylarƒ± ekle
    for (const voteDoc of votesSnapshot.docs) {
      const voteData = voteDoc.data();
      const predictionDoc = await getDoc(doc(db, 'predictions', voteData.predictionId));
      
      if (predictionDoc.exists()) {
        const predictionData = predictionDoc.data();
        activities.push({
          id: voteDoc.id,
          type: 'vote',
          action: 'Oy verdi',
          predictionTitle: predictionData.question,
          predictionId: voteData.predictionId,
          choice: voteData.choice,
          status: predictionData.status,
          result: predictionData.result,
          createdAt: voteData.createdAt.toDate(),
          category: getCategoryFromQuestion(predictionData.question)
        });
      }
    }
    
    // Olu≈üturulan tahminleri ekle
    for (const predictionDoc of predictionsSnapshot.docs) {
      const predictionData = predictionDoc.data();
      activities.push({
        id: predictionDoc.id,
        type: 'prediction',
        action: 'Tahmin olu≈üturdu',
        predictionTitle: predictionData.question,
        predictionId: predictionDoc.id,
        status: predictionData.status,
        result: predictionData.result,
        totalVotes: predictionData.totalVotes,
        createdAt: predictionData.createdAt.toDate(),
        category: getCategoryFromQuestion(predictionData.question)
      });
    }
    
    // Tarihine g√∂re sƒ±rala
    activities.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
    
    console.log(`‚úÖ ${activities.length} aktivite bulundu`);
    return activities.slice(0, 10); // En son 10 aktiviteyi d√∂nd√ºr
  } catch (error) {
    console.error('Kullanƒ±cƒ± aktivitelerini alma hatasƒ±:', error);
    throw error;
  }
};

// Kategorileri tahmin sorusundan √ßƒ±kar
const getCategoryFromQuestion = (question: string): string => {
  const lowerQuestion = question.toLowerCase();
  
  if (lowerQuestion.includes('bitcoin') || lowerQuestion.includes('kripto') || lowerQuestion.includes('ethereum')) {
    return 'Kripto';
  } else if (lowerQuestion.includes('apple') || lowerQuestion.includes('iphone') || lowerQuestion.includes('teknoloji') || lowerQuestion.includes('yapay zeka')) {
    return 'Teknoloji';
  } else if (lowerQuestion.includes('futbol') || lowerQuestion.includes('avrupa') || lowerQuestion.includes('≈üampiyona') || lowerQuestion.includes('spor')) {
    return 'Spor';
  } else if (lowerQuestion.includes('ekonomi') || lowerQuestion.includes('piyasa') || lowerQuestion.includes('borsa')) {
    return 'Ekonomi';
  } else if (lowerQuestion.includes('siyaset') || lowerQuestion.includes('se√ßim') || lowerQuestion.includes('h√ºk√ºmet')) {
    return 'Siyaset';
  } else {
    return 'Genel';
  }
};

// Kullanƒ±cƒ±nƒ±n rozetlerini hesapla
export const getUserBadges = async (userId: string): Promise<UserBadge[]> => {
  try {
    console.log(`üèÜ Kullanƒ±cƒ±nƒ±n rozetleri hesaplanƒ±yor: ${userId}`);
    
    const user = await getUser(userId);
    if (!user) return [];
    
    const badges = [];
    
    // ƒ∞lk Tahmin rozeti
    const userPredictionsQuery = query(
      collection(db, 'predictions'),
      where('creatorId', '==', userId),
      limit(1)
    );
    const userPredictionsSnapshot = await getDocs(userPredictionsQuery);
    
    if (!userPredictionsSnapshot.empty) {
      badges.push({
        id: 'first_prediction',
        name: 'ƒ∞lk Tahmin',
        description: 'ƒ∞lk tahmini olu≈üturdun!',
        icon: 'ü•á',
        unlockedAt: userPredictionsSnapshot.docs[0].data().createdAt.toDate()
      });
    }
    
    // Seri Yapƒ±cƒ± rozeti (5 doƒüru tahmin)
    if (user.correctPredictions >= 5) {
      badges.push({
        id: 'streak_master',
        name: 'Seri Yapƒ±cƒ±',
        description: '5 doƒüru tahmin serisi yaptƒ±n!',
        icon: 'üèÜ',
        unlockedAt: new Date() // Ger√ßek unlock tarihini hesaplamak i√ßin daha karma≈üƒ±k logic gerekir
      });
    }
    
    // Keskin Ni≈üancƒ± rozeti (10 doƒüru tahmin)
    if (user.correctPredictions >= 10) {
      badges.push({
        id: 'sharp_shooter',
        name: 'Keskin Ni≈üancƒ±',
        description: '10 doƒüru tahmin yaptƒ±n!',
        icon: 'üéØ',
        unlockedAt: new Date()
      });
    }
    
    // Y√ºksek Ba≈üarƒ± rozeti (%75+ ba≈üarƒ± oranƒ±, minimum 10 tahmin)
    if (user.totalPredictions >= 10) {
      const successRate = (user.correctPredictions / user.totalPredictions) * 100;
      if (successRate >= 75) {
        badges.push({
          id: 'high_accuracy',
          name: 'Y√ºksek Ba≈üarƒ±',
          description: '%75+ ba≈üarƒ± oranƒ±!',
          icon: 'üíé',
          unlockedAt: new Date()
        });
      }
    }
    
    // XP Avcƒ±sƒ± rozeti (1000+ XP)
    if (user.xp >= 1000) {
      badges.push({
        id: 'xp_hunter',
        name: 'XP Avcƒ±sƒ±',
        description: '1000+ XP topladƒ±n!',
        icon: '‚ö°',
        unlockedAt: new Date()
      });
    }
    
    // Aktif Katƒ±lƒ±mcƒ± rozeti (20+ tahmin)
    if (user.totalPredictions >= 20) {
      badges.push({
        id: 'active_participant',
        name: 'Aktif Katƒ±lƒ±mcƒ±',
        description: '20+ tahmine katƒ±ldƒ±n!',
        icon: 'üî•',
        unlockedAt: new Date()
      });
    }
    
    console.log(`üèÜ ${badges.length} rozet bulundu`);
    return badges as unknown as UserBadge[];
  } catch (error) {
    console.error('Kullanƒ±cƒ± rozetlerini hesaplama hatasƒ±:', error);
    throw error;
  }
};

// Level hesapla
export const calculateUserLevel = (xp: number): { level: number, currentXP: number, requiredXP: number, progress: number } => {
  // Her level i√ßin gerekli XP miktarlarƒ± (kademeli artƒ±≈ü)
  const levelThresholds = [
    0,     // Level 1
    100,   // Level 2
    300,   // Level 3  
    600,   // Level 4
    1000,  // Level 5
    1500,  // Level 6
    2200,  // Level 7
    3000,  // Level 8
    4000,  // Level 9
    5500,  // Level 10
  ];
  
  let level = 1;
  let currentXP = xp;
  let requiredXP = levelThresholds[1];
  
  // Kullanƒ±cƒ±nƒ±n level'ini bul
  for (let i = 0; i < levelThresholds.length - 1; i++) {
    if (xp >= levelThresholds[i] && xp < levelThresholds[i + 1]) {
      level = i + 1;
      currentXP = xp - levelThresholds[i];
      requiredXP = levelThresholds[i + 1] - levelThresholds[i];
      break;
    }
  }
  
  // Max level kontrol√º
  if (xp >= levelThresholds[levelThresholds.length - 1]) {
    level = levelThresholds.length;
    currentXP = xp - levelThresholds[levelThresholds.length - 1];
    requiredXP = 1000; // Max level sonrasƒ± her 1000 XP'de bir "level"
  }
  
  const progress = (currentXP / requiredXP) * 100;
  
  return { level, currentXP, requiredXP, progress };
};

// Badge System Functions
export const checkAndAwardBadges = async (userId: string, currentXP: number): Promise<UserBadge[]> => {
  try {
    console.log(`üèÜ Badge kontrol√º - User: ${userId}, XP: ${currentXP}`);
    
    // Kullanƒ±cƒ±nƒ±n mevcut rozetlerini al
    const userBadgesRef = collection(db, 'userBadges');
    const userBadgesQuery = query(userBadgesRef, where('userId', '==', userId));
    const userBadgesSnapshot = await getDocs(userBadgesQuery);
    
    const existingBadges = userBadgesSnapshot.docs.map(doc => doc.data().badgeId);
    console.log('üéØ Mevcut rozetler:', existingBadges);
    
    const newBadges: UserBadge[] = [];
    
    // Welcome rozetini kontrol et (ilk giri≈ü)
    if (!existingBadges.includes('welcome')) {
      const welcomeBadge: UserBadge = {
        userId,
        badgeId: 'welcome',
        earnedAt: new Date(),
        isNew: true
      };
      
      await addDoc(userBadgesRef, welcomeBadge);
      newBadges.push(welcomeBadge);
      console.log('üéâ Welcome rozeti verildi!');
    }
    
    // XP bazlƒ± rozetleri kontrol et
    const xpBadges = BADGE_DEFINITIONS.filter(badge => badge.type === 'xp');
    
    for (const badge of xpBadges) {
      if (currentXP >= badge.xpRequired && !existingBadges.includes(badge.id)) {
        const userBadge: UserBadge = {
          userId,
          badgeId: badge.id,
          earnedAt: new Date(),
          isNew: true
        };
        
        await addDoc(userBadgesRef, userBadge);
        newBadges.push(userBadge);
        console.log(`üéâ ${badge.name} rozeti verildi! (${badge.xpRequired} XP)`);
      }
    }
    
    return newBadges;
  } catch (error) {
    console.error('‚ùå Badge kontrol√º hatasƒ±:', error);
    return [];
  }
};

export const getUserBadgesNew = async (userId: string): Promise<UserBadge[]> => {
  try {
    const userBadgesRef = collection(db, 'userBadges');
    const userBadgesQuery = query(
      userBadgesRef, 
      where('userId', '==', userId),
      orderBy('earnedAt', 'desc')
    );
    
    const snapshot = await getDocs(userBadgesQuery);
    return snapshot.docs.map(doc => ({
      ...doc.data(),
      earnedAt: doc.data().earnedAt.toDate()
    })) as UserBadge[];
  } catch (error) {
    console.error('‚ùå Kullanƒ±cƒ± rozetleri alƒ±namadƒ±:', error);
    return [];
  }
};

export const getBadgeProgress = async (userId: string, currentXP: number): Promise<BadgeProgress> => {
  try {
    // Kullanƒ±cƒ±nƒ±n mevcut rozetlerini al
    const userBadges = await getUserBadgesNew(userId);
    const earnedBadgeIds = userBadges.map(badge => badge.badgeId);
    
    // Bir sonraki rozeti bul
    const nextBadge = BADGE_DEFINITIONS
      .filter(badge => badge.type === 'xp' && !earnedBadgeIds.includes(badge.id))
      .sort((a, b) => a.xpRequired - b.xpRequired)[0];
    
    let progressPercentage = 100;
    
    if (nextBadge) {
      // Bir √∂nceki rozet seviyesini bul
      const previousBadge = BADGE_DEFINITIONS
        .filter(badge => badge.type === 'xp' && badge.xpRequired < nextBadge.xpRequired)
        .sort((a, b) => b.xpRequired - a.xpRequired)[0];
      
      const previousXP = previousBadge ? previousBadge.xpRequired : 0;
      const nextXP = nextBadge.xpRequired;
      
      progressPercentage = Math.min(100, ((currentXP - previousXP) / (nextXP - previousXP)) * 100);
    }
    
    return {
      userId,
      currentXP,
      nextBadge,
      progressPercentage
    };
  } catch (error) {
    console.error('‚ùå Badge progress hesaplanamadƒ±:', error);
    return {
      userId,
      currentXP,
      nextBadge: null,
      progressPercentage: 100
    };
  }
};

export const markBadgeAsViewed = async (userId: string, badgeId: string): Promise<void> => {
  try {
    const userBadgesRef = collection(db, 'userBadges');
    const userBadgesQuery = query(
      userBadgesRef,
      where('userId', '==', userId),
      where('badgeId', '==', badgeId)
    );
    
    const snapshot = await getDocs(userBadgesQuery);
    
    if (!snapshot.empty) {
      const doc = snapshot.docs[0];
      await updateDoc(doc.ref, { isNew: false });
      console.log(`‚úÖ ${badgeId} rozeti g√∂r√ºld√º olarak i≈üaretlendi`);
    }
  } catch (error) {
    console.error('‚ùå Rozet g√ºncelleme hatasƒ±:', error);
  }
};

export const getBadgeById = (badgeId: string): Badge | null => {
  return BADGE_DEFINITIONS.find(badge => badge.id === badgeId) || null;
};

// Helper function to get user XP
export const getUserXP = async (userId: string): Promise<number> => {
  try {
    const userRef = doc(db, 'users', userId);
    const userDoc = await getDoc(userRef);
    
    if (userDoc.exists()) {
      return userDoc.data().totalXP || 0;
    }
    
    return 0;
  } catch (error) {
    console.error('‚ùå Kullanƒ±cƒ± XP alƒ±namadƒ±:', error);
    return 0;
  }
}; 